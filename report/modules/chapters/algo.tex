\section{Описание алгоритма и стуктур данных}

Работа выполнена на языке \verb|Python| версии \verb|3.8|.

\subsection*{Структуры данных}

Транспортная сеть представлена классом \verb|FlowNetwork|.
\verb|FlowNetwork| --- граф, хранящий вершины и рёбра.
Так же \verb|FlowNetwork| хранит имя истока и стока 
троспортной сети.

Вершины (класс \verb|Vertex|) хранятся в виде
асооциативного массива пар (имя вершины -- объект вершины)

Вершина содержит только своё имя.

Рёбра (класс \verb|Edge|) хранятся в виде
асооциативного массива пар ((вершина 1, вершина 2)  -- объект ребра)

Ребро хранит 
стартовую ($ v_1 $), конечную ($ v_2 $) вершины,
пропускную способность $ c_{v_1, v_2} $ и
поток $ f_{v_1, v_2} $, проходящий через ребро.
Из ребра можно молучить остаточную пропускную способность $ c^{f}_{v_1, v_2} $,
которая вычисляется как $ c_{v_1, v_2} - f_{v_1, v_2} $.

\subsection*{Алгоритм Эдмондса -- Карпа}

После изициализации \verb|FlowNetwork|
списком аргументов 

$(
    ($ v_{i1} $, $ v_{i2} $, $ c_{v_{i1}, v_{i2}} $),
    ($ v_{j1} $, $ v_{j2} $, $ c_{v_{j1}, v_{j2}} $),
    \dots,
    ($ v_{n1} $, $ v_{n2} $, $ c_{v_{n1}, v_{n2}} $)
)$

автоматически запускается 
алгоритм Эдмондса -- Карпа
по поиску максимального потока:

\begin{itemize}
    \item Пока существует увеличивающий путь $ ap $:
    \subitem Выбираем в $ ap $ 
             мимнимальную остаточную пропускную способность 
             $ с_{min} = c^{f}_{v_1, v_2} $.
    \subitem Увеличиваем потоки всех рёбер из $ ap $ на $ с_{min} $
\end{itemize}

Увеличивающий путь $ ap $ ищется так:

\begin{itemize}
    \item Создаём очередь вершин и помещаем в неё исток.
    \item Помечаем исток как посещённую вершину.
    \item Пока очередь не пуста:
    \subitem Выбираем последнюю вершину $ u $ из очереди.
    \subitem Для всех вершин $ v \in V $:
    \subsubitem Если существует ребро $ (u, v) $
                выбраем $ с_f = c^{f}_{u, v} $, или,
                если существует ребро $ (v, u) $,
                выбираем $ c_f = -c^{f}_{u, v} $.
    \subsubitem Если $ c_f > 0 $ и $ v $ ещё не посещена,
                отмечаем $ v $ как посещённую, с родителем $ u $.
    \subsubitem Если $ v = t $, возвращаем путь $ (v, \dots, t) $,
                иначе добавляем $ v $ в очередь.
\end{itemize}
